//
//  Dataset.m
//  Marching Cubes
//
//  Created by Steve Challis on 25/01/2010.
//  Copyright 2010 All rights reserved.
//

#import "Dataset.h"
#import "functions.h"
#import "mc_tables.h"
#include <stdlib.h>

int signof(float a) { return (a == 0) ? 0 : (a<0 ? -1 : 1); }

@implementation Dataset

@synthesize scalarData, rawData, dimensions, triangles, num_triangles, num_allocated, num_elements, isovalue, minValue, maxValue, smoothedNormals;

// Use NSArray *sortedArray; sortedArray = [anArray sortedArrayUsingFunction:intSort context:NULL];
NSInteger pointSort(Hit *point1, Hit *point2, void *context)
{
    float v1 = [[point1 location] chebyshev:context];
    float v2 = [[point2 location] chebyshev:context];
    if (v1 < v2)
        return NSOrderedAscending;
    else if (v1 > v2)
        return NSOrderedDescending;
    else
        return NSOrderedSame;
}

-(id)init
{
    self = [super init];
    [self clearData];
    return self;
}

-(void)clearData {
    free(triangles);
    [self setTriangles:NULL];
    [self setNum_triangles:0];
    [self setNum_allocated:0];
    [self setNum_elements:0];
    [self setNum_elements:0];
}

- (void)initWithContentsOfFile:(NSString *)path {
    NSLog([@"Loading " stringByAppendingString:path]);
    [self clearData];
    NSError *error;
    // Read file
    self.rawData = [[[NSString alloc] initWithContentsOfFile:path
                                     encoding:NSUTF8StringEncoding
                                     error:&error] autorelease];

    // Setup scanner that skips spaces and newlines
    NSScanner *scanner = [NSScanner scannerWithString:[self rawData]];
    [scanner setCharactersToBeSkipped:
     [NSCharacterSet characterSetWithCharactersInString:@"\n\t\r "]];
    NSMutableArray *points = [NSMutableArray array];
    float density;
    
    // Extract scalar values from raw data
    int count = 0;
    while ( [scanner scanFloat:&density] ) {
        [points addObject: [NSNumber numberWithFloat:density]];
        if (count>3) {
            if (density > maxValue) { [self setMaxValue:density]; }
            if (density < minValue) { [self setMinValue:density]; }
        } else if (count>2) {
            [self setMaxValue:density];
            [self setMinValue:density];
        }
        count += 1;
    }
    
    // Assign first 3 points as the dimensions
    NSInteger split = 3;
    NSRange range = NSMakeRange(0, split);
    NSIndexSet *indexes = [NSIndexSet indexSetWithIndexesInRange:range];
    [self setDimensions:[points objectsAtIndexes:indexes]];
    
    // Assign remainder as data
    NSRange range2 = NSMakeRange(split, [points count]-split);
    NSIndexSet *indexes2 = [NSIndexSet indexSetWithIndexesInRange:range2];
    [self setScalarData:[points objectsAtIndexes:indexes2]];
    
    NSLog(@"Dimensions: %d %d %d", [[dimensions objectAtIndex:0] intValue], [[dimensions objectAtIndex:1] intValue], [[dimensions objectAtIndex:2] intValue]);
    NSLog(@"Datapoints: %d", [scalarData count]);
    
    // Smoothed normals are expensive to compute
    // so turn them off by default
    [self setSmoothedNormals:FALSE];
}

- (void)computeIlluminationWithSamples:(int)samples fromCamera:(BOOL)fromCamera confined:(BOOL)confined {
    /* This method will sample the volume using different techniques and
     * generate a rectilinear grid of illumination samples. The regular
     * grid is generated by interpolating the color and normal data at
     * the vertices.
     */
    
    NSLog(@"Computing illumination samples");
    
    hits = [[NSMutableArray alloc] init];
    
    if (fromCamera==TRUE) {
        // generate 1 ray per sample
        NSLog(@"Computing samples from camera ...");
        for (int i=0; i<samples; i+=1) {
            float x = (float)rand()/(float)RAND_MAX*([[dimensions objectAtIndex:0] floatValue]-1);
            float y = (float)rand()/(float)RAND_MAX*([[dimensions objectAtIndex:1] floatValue]-1);
            float iso = (float)rand()/(float)RAND_MAX;
            Ray *front  = [[Ray alloc] initWithOrigin:[[Vec3 alloc] initiWithX:x Y:y Z:0]
                                            direction:[[Vec3 alloc] initiWithX:0 Y:0 Z:1]];
            float v = [self isovalueFromUnitIsovalue:iso];
            Hit *hit_front  = [self intersectRay:front withIsovalue:v];
            if (hit_front) [hits addObject:hit_front];
        }
    } else {
        // Confine samples to specific isovalues
        if (confined == TRUE) {
            NSLog(@"Computing confined samples ...");
            for (int i=0; i<10; i+=1) {
                for (int s=0; s<samples/10; s++) {
                    float x = (float)rand()/(float)RAND_MAX*([[dimensions objectAtIndex:0] floatValue]-1);
                    float y = (float)rand()/(float)RAND_MAX*([[dimensions objectAtIndex:1] floatValue]-1);
                    float z = (float)rand()/(float)RAND_MAX*([[dimensions objectAtIndex:2] floatValue]-1);
                    float iso = 0.5;
                }
            }
        } else {
            NSLog(@"Computing non-confined samples ...");
            for (int s=0; s<samples; s++) {
                float rx = (float)rand()/(float)RAND_MAX*([[dimensions objectAtIndex:0] floatValue]-1);
                float ry = (float)rand()/(float)RAND_MAX*([[dimensions objectAtIndex:1] floatValue]-1);
                float rz = (float)rand()/(float)RAND_MAX*([[dimensions objectAtIndex:2] floatValue]-1);
                
                Vec3 *position = [Vec3 withX:rx Y:ry Z:rz];
                Vec3 *voxel = [position c_floor];
                
                float p = [self trilinearInterpolationWithPosition:position inVoxel:voxel];
                //NSLog(@"p: %f", p);
                
                /* Compute normals using similar method to ray-intersection method below */
                
                int i = [voxel x];
                int j = [voxel y];
                int k = [voxel z];
                int y = (int)[[dimensions objectAtIndex:1] intValue];
                int z = (int)[[dimensions objectAtIndex:2] intValue];
                
                int is[8] = {
                    // Bits are in reverse order
                    k + j*z + i*z*y,                // 000  0
                    k + j*z + (i+1)*z*y,            // 001  1
                    k + (j+1)*z + i*z*y,            // 010  2
                    k + (j+1)*z + (i+1)*z*y,        // 011  3
                    (k+1) + j*z + i*z*y,            // 100  4
                    (k+1) + j*z + (i+1)*z*y,        // 101  5
                    (k+1) + (j+1)*z + i*z*y,        // 110  6
                    (k+1) + (j+1)*z + (i+1)*z*y     // 111  7
                };
                
                Vec3 *vec_norm = [Vec3 withX:0 Y:0 Z:1];
            
                float u1 = ([position x] - [voxel x]);  // voxels are 1 unit
                float v1 = ([position y] - [voxel y]);  // rendering quotient
                float w1 = ([position z] - [voxel z]);  // unnecessary
                
                float u[2] = {1 - u1, u1};
                float v[2] = {1 - v1, v1};
                float w[2] = {1 - w1, w1};
                
                int convert[2][2][2] = {
                    { { 0, 4 }, { 2, 6 } },
                    { { 1, 5 }, { 3, 7 } } };
                
                // normals
                double normal[3] = { 0, 0, 0 };
                for (int iv=0; iv<2; iv++) {
                    for (int jv=0; jv<2; jv++) {
                        for (int kv=0; kv<2; kv++) {
                            normal[0] += (double)pow(-1, iv+1) * v[jv] * w[kv] * [[[self scalarData] objectAtIndex:is[convert[iv][jv][kv]]] doubleValue];
                            normal[1] += (double)pow(-1, jv+1) * u[iv] * w[kv] * [[[self scalarData] objectAtIndex:is[convert[iv][jv][kv]]] doubleValue];
                            normal[2] += (double)pow(-1, kv+1) * u[iv] * v[jv] * [[[self scalarData] objectAtIndex:is[convert[iv][jv][kv]]] doubleValue];
                        }
                    }
                }
                Normalize(normal);
                vec_norm = [Vec3 withX:-normal[0] Y:-normal[1] Z:-normal[2]];
                
                /* end computation of normals */
                    
                Vec3 *light = [Vec3 withX:0.4 Y:1.2 Z:-1.0];
                Vec3 *to_light = [light c_subtract:position];
                [to_light normalize];
                
                // Compute color using simple dot-product lighting
                float dot = [vec_norm dot:to_light];
                dot = (dot+fabs(dot))/2;  // cap at 0
                float ambient = 0.4;
                Vec3 *color = [Vec3 withX:dot+ambient Y:dot+ambient Z:dot+ambient];
                
                Hit *hit = [[Hit alloc] initWithLocation:position rgb:color normal:vec_norm isovalue:p];
                if (hit) [hits addObject:hit];
            }
            
            // Generate recilinear grid from randomly spaced samples
            // using Shepards method interpolation
            hits = [self shepardInterpolateGrid:hits];
            int xdim = [[[self dimensions] objectAtIndex:0] intValue];
            int ydim = [[[self dimensions] objectAtIndex:1] intValue];
            int zdim = [[[self dimensions] objectAtIndex:2] intValue];
            GLfloat image[xdim][ydim][zdim][3];
            
            // Create array of texture values
            for (int i=0; i<xdim; i++) {
                for (int j=0; j<ydim; j++) {
                    for (int k=0; k<zdim; k++) {
                        int index = k + (j*ydim) + (i*ydim*zdim);
                        //NSLog(@"ijk %d %d %d", i, j, k);
                        //NSLog(@"ind %d", index);
                        image[i][j][k][0] = [[[hits objectAtIndex:index] rgb] x];
                        image[i][j][k][1] = [[[hits objectAtIndex:index] rgb] y];
                        image[i][j][k][2] = [[[hits objectAtIndex:index] rgb] z];
                        /*
                        image[i][j][k][0] = (float)i/(float)xdim;
                        image[i][j][k][1] = 0;
                        image[i][j][k][2] = 0;
                         */
                    }
                }
            }
            
            static GLuint texMap;
            glGenTextures(1, &texMap);
            glBindTexture(GL_TEXTURE_3D, texMap);

            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP);
            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP);
            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP);
            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            //glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
            //glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            GLfloat gr = {0,1,0,0}; // Green texture border
            glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_BORDER_COLOR, gr);
            glTexImage3D(GL_TEXTURE_3D, 0, GL_RGB, xdim, ydim, zdim,
                         0, GL_RGB, GL_FLOAT, image[0][0][0]);
        }
    }
    
    NSLog(@"Finished computing samples!");
    NSLog(@"Hits: %d", [hits count]);
}

- (NSMutableArray *)shepardInterpolateGrid:(NSMutableArray *)grid {
    /* The basic idea is to iterate over the points in
     * the new rectilinear grid and find the n closest
     * sample points, taking the weighted average where
     * the weighting is based on chebyshev distance.
     */
    
    NSMutableArray *newTexture;
    newTexture = [[NSMutableArray alloc] init];
 
    NSLog(@"Shepard interpolating ...");
    
    for (int i=0; i<[[[self dimensions] objectAtIndex:0] intValue]; i++) {
        for (int j=0; j<[[[self dimensions] objectAtIndex:1] intValue]; j++) {
            for (int k=0; k<[[[self dimensions] objectAtIndex:2] intValue]; k++) {
                
                // Sort the sample points with a chebyshev distance function
                NSArray *sortedArray;
                Vec3 *current = [Vec3 withX:i Y:j Z:k];
                sortedArray = [grid sortedArrayUsingFunction:pointSort context:current];
                
                // Number of nearest samples to take
                int samples = 7;
                
                float sumWeights = 0;
                float pointWeights[samples];
                Vec3 *localColorSum = [Vec3 withX:0 Y:0 Z:0];
                Vec3 *localNormalSum = [Vec3 withX:0 Y:0 Z:0];
                
                // Choose n nearest samples
                for (int n=0; n<samples; n++) {
                    Hit *sample = [sortedArray objectAtIndex:n];
                    float d = [current chebyshev:sample.location];
                    float pointWeight = 1/pow(d,0.5);
                    sumWeights += pointWeight;
                    pointWeights[n] = pointWeight;
                }
                
                // Get the product of the weight and color value then sum all of these
                for (int n=0; n<samples; n++) {
                    float weight = pointWeights[n] / sumWeights;
                    [localColorSum add:[[[sortedArray objectAtIndex:n] rgb] product:weight]];
                    [localNormalSum add:[[[sortedArray objectAtIndex:n] normal] product:weight]];
                }
                
                // Create hit and add to new rectilinear grid
                Hit *hit = [[Hit alloc] initWithLocation:current
                                                     rgb:localColorSum
                                                  normal:localNormalSum
                                                isovalue:0.5];
                [newTexture addObject:hit];
                //NSLog(@"hit: %@", hit);
            }
        }
        NSLog(@"%d/%d", i+1, [[[self dimensions] objectAtIndex:0] intValue]);
    }
    
    NSLog(@"Done interpolating!");
    NSLog(@"count %d", [newTexture count]);
    return newTexture;
}

- (Vec3 *)voxelFromX:(float)x Y:(float)y Z:(float)z {
    return [Vec3 withX:floor(x) Y:floor(y) Z:floor(z)];
}

- (float)isovalueFromUnitIsovalue:(float)value {
    // given a value between 0 and 1, return
    // corresponding isovalues for dataset
    return value * (maxValue - minValue) + minValue;
}

- (void)recalculateWithIsovalue:(float)value {
    
    [self clearData];
    float normIso = [self isovalueFromUnitIsovalue:value];
    [self setIsovalue:normIso];
    
    int x = (int)[[dimensions objectAtIndex:0] intValue];
    int y = (int)[[dimensions objectAtIndex:1] intValue];
    int z = (int)[[dimensions objectAtIndex:2] intValue];
    
    // Loop over cells in dataset
    for (int i=0; i<x-1; i++) {
        for (int j=0; j<y-1; j++) {
            for (int k=0; k<z-1; k++) {
                
                // Get surrounding vertices indexes
                int is[8] = {
                    // Bits are in reverse order
                    k + j*z + i*z*y,            // 000  0
                    k + j*z + (i+1)*z*y,        // 001  1
                    k + (j+1)*z + i*z*y,        // 010  2
                    k + (j+1)*z + (i+1)*z*y,    // 011  3
                    (k+1) + (j*z) + i*z*y,      // 100  4
                    (k+1) + (j*z) + (i+1)*z*y,  // 101  5
                    (k+1) + (j+1)*z + i*z*y,    // 110  6
                    (k+1) + (j+1)*z + (i+1)*z*y // 111  7
                };
                
                double vs[8];
                for (int n=0; n<8; n++) {
                    vs[n] = [[[self scalarData] objectAtIndex:is[n]] doubleValue];
                }
                
                // Figure out which ones are above the threshold
                // Label values 1 or 0 depending on whether they are above isovalue
                int b_vs[8];
                for (int n=0; n<8; n++) {
                    b_vs[n] = vs[n] >= normIso;
                }
                
                // Get integer value to lookup
                int lookup = b_vs[0] + (b_vs[1]*2) +
                (b_vs[2]*4) + (b_vs[3]*8) +
                (b_vs[4]*16) + (b_vs[5]*32) +
                (b_vs[6]*64) + (b_vs[7]*128);
                
                // Get triangles
                for (int t=0; t<triangleTable[lookup][0]; t++) {
                    // Edges
                    int edges[3] = {
                        triangleTable[lookup][(t*3)+1],
                        triangleTable[lookup][(t*3)+2],
                        triangleTable[lookup][(t*3)+3]
                    };
                    // Get edge points
                    int edgePoints[6];
                    for (int pairs=0; pairs<3; pairs++) {
                        for (int pair=0; pair<2; pair++) {
                            edgePoints[(pairs*2)+pair] = edgeTable[edges[pairs]][pair];
                        }
                    };
                    // Figure out triangle points
                    Triangle triangle;
                    for (int edge=0; edge<3; edge++) {
                        // points at end of edges
                        int point1 = edgePoints[2*edge];
                        int point2 = edgePoints[(2*edge+1)];
                        // Binary values, to find out which dimension to interpolate
                        // Remember that the bits are reversed
                        int p1[3] = {
                            vertPos[edgePoints[2*edge]][2],
                            vertPos[edgePoints[2*edge]][1],
                            vertPos[edgePoints[2*edge]][0]};
                        int p2[3] = {
                            vertPos[edgePoints[(2*edge+1)]][2],
                            vertPos[edgePoints[(2*edge+1)]][1],
                            vertPos[edgePoints[(2*edge+1)]][0]};
                        // coords of those points
                        double c1 = [[scalarData objectAtIndex:is[point1]] doubleValue];
                        double c2 = [[scalarData objectAtIndex:is[point2]] doubleValue];
                        double interp = (isovalue-c1)/(c2-c1);
                        double px = interp*abs(p1[0]-p2[0])+(p1[0]*p2[0]);
                        double py = interp*abs(p1[1]-p2[1])+(p1[1]*p2[1]);
                        double pz = interp*abs(p1[2]-p2[2])+(p1[2]*p2[2]);
                        GLdouble point_pos[3] = {
                            // Normalise to +-0.5
                            ((i+px)-((x-1)/2.0))/(x-1),
                            ((j+py)-((y-1)/2.0))/(y-1),
                            ((k+pz)-((z-1)/2.0))/(z-1)};
                        GLdouble nn_point_pos[3] = {
                            // non normalised
                            i+px, j+py, k+pz};
                        triangle.points[edge][0][0] = point_pos[0];
                        triangle.points[edge][0][1] = point_pos[1];
                        triangle.points[edge][0][2] = point_pos[2];
                        triangle.nn_points[edge][0][0] = nn_point_pos[0];
                        triangle.nn_points[edge][0][1] = nn_point_pos[1];
                        triangle.nn_points[edge][0][2] = nn_point_pos[2];
                    };
                    [self setNum_triangles:[self num_triangles]+1];
                    //Get the surface normal for this triangle
                    getFaceNormal(triangle.normal, triangle.points[0][0], triangle.points[1][0], triangle.points[2][0]);
                    [self addTriangle:triangle];
                }
            }
        }
    }
    [self setSmoothedNormals:FALSE];
    NSLog(@"Isovalue:%.3f Triangles: %d", isovalue, num_triangles);
}
    
- (void)computeVertexNormals {
    // get vertex normals
    if (num_triangles>-1) {
        NSLog(@"Getting vertex normals...");
        for (int t=0; t<num_triangles; t++) {
            for (int v=0; v<3; v++) {
                triangles[t].points[v][1][0] = 0;
                triangles[t].points[v][1][1] = 0;
                triangles[t].points[v][1][2] = 0;
                // loop through vertices again
                for (int t2=0; t2<num_triangles; t2++) {
                    //double weight = area(triangles[t2].points);
                    if (t2!=-1) { // Don't average triangle with itself
                        for (int v2=0; v2<3; v2++) {
                            // Sum normals from faces with same vertex
                            if (triangles[t].points[v][0][0]==triangles[t2].points[v2][0][0] &&
                                triangles[t].points[v][0][1]==triangles[t2].points[v2][0][1] &&
                                triangles[t].points[v][0][2]==triangles[t2].points[v2][0][2]) {
                                // matching vertices, sum normals
                                triangles[t].points[v][1][0] += triangles[t2].normal[0];
                                triangles[t].points[v][1][1] += triangles[t2].normal[1];
                                triangles[t].points[v][1][2] += triangles[t2].normal[2];
                            }
                        }
                    }
                }
                Normalize(triangles[t].points[v][1]);
            }
        }
    }
    [self setSmoothedNormals:TRUE];
}

- (void)renderWithSmoothing:(BOOL)smoothing cellShading:(BOOL)cell {
    if (smoothedNormals==FALSE && smoothing==TRUE) {
        [self computeVertexNormals];
    }
    for (int t=0; t<num_triangles; t++) {
        /*if (cell==TRUE) {
            // Cell shading :)
            glLineWidth(5.0f);
            glColor3f(0.3f, 0.4f, 0.5f);
            glEnable(GL_CULL_FACE);
            glDisable(GL_LIGHTING);
            glCullFace(GL_FRONT);
            glPolygonMode(GL_BACK, GL_LINE);
            glBegin(GL_TRIANGLES);
            if (smoothing==FALSE) {glNormal3f(triangles[t].normal[0], triangles[t].normal[1], triangles[t].normal[2]);}
            for (int i=0; i<3; i++) {
                GLfloat p[3] = {triangles[t].points[i][0][0], triangles[t].points[i][0][1], triangles[t].points[i][0][2]};
                GLfloat n[3] = {triangles[t].points[i][1][0], triangles[t].points[i][1][1], triangles[t].points[i][1][2]};
                if (smoothing==TRUE) {glNormal3f(n[0], n[1], n[2]);}
                glVertex3f(p[0], p[1], p[2]);
            }
            glEnd();
            glDisable(GL_CULL_FACE);
            glEnable(GL_LIGHTING);
            glColor3f(0.5f, 0.6f, 0.7f);
        }*/
        if (cell==TRUE) {
            glEnable(GL_TEXTURE_3D);
            glBegin(GL_TRIANGLES);
            if (smoothing==FALSE) {glNormal3f(triangles[t].normal[0], triangles[t].normal[1], triangles[t].normal[2]);}
            for (int i=0; i<3; i++) {
                GLfloat p[3] = {triangles[t].points[i][0][0], triangles[t].points[i][0][1], triangles[t].points[i][0][2]};
                GLfloat n[3] = {triangles[t].points[i][1][0], triangles[t].points[i][1][1], triangles[t].points[i][1][2]};
                if (smoothing==TRUE) {glNormal3f(n[0], n[1], n[2]);}
				glTexCoord3f(p[2]+0.5, p[1]+0.5, p[0]+0.5);
                glVertex3f(p[0], p[1], p[2]);
                //NSLog(@"%f", p[0]+0.5);
            }
            glEnd();
            glDisable(GL_TEXTURE_3D);
        } else {
            glBegin(GL_TRIANGLES);
            if (smoothing==FALSE) {glNormal3f(triangles[t].normal[0], triangles[t].normal[1], triangles[t].normal[2]);}
            for (int i=0; i<3; i++) {
                GLfloat p[3] = {triangles[t].points[i][0][0], triangles[t].points[i][0][1], triangles[t].points[i][0][2]};
                GLfloat n[3] = {triangles[t].points[i][1][0], triangles[t].points[i][1][1], triangles[t].points[i][1][2]};
                if (smoothing==TRUE) {glNormal3f(n[0], n[1], n[2]);}
                glVertex3f(p[0], p[1], p[2]);
            }
            glEnd();
        }
    }
}

- (void)renderNormalsAtScale:(float)scale withSmoothing:(BOOL)smoothing {
    for (int t=0; t<num_triangles; t++) {
        if (smoothing==FALSE) {
            glBegin(GL_LINES);
            glColor3f(1.0f, 1.0f, 1.0f);
            glVertex3f(triangles[t].points[0][0][0], triangles[t].points[0][0][1], triangles[t].points[0][0][2]);
            glColor3f(0.0f, 0.0f, 1.0f);
            glVertex3f(triangles[t].points[0][0][0]+triangles[t].normal[0]*scale,triangles[t].points[0][0][1]+triangles[t].normal[1]*scale,triangles[t].points[0][0][2]+triangles[t].normal[2]*scale);
            glEnd();
        } else {
            for (int v=0; v<3; v++) {
                glBegin(GL_LINES);
                glColor3f(1.0f, 1.0f, 1.0f);
                glVertex3f(triangles[t].points[v][0][0], triangles[t].points[v][0][1], triangles[t].points[v][0][2]);
                glColor3f(0.0f, 0.0f, 1.0f);
                glVertex3f(triangles[t].points[v][0][0]+triangles[t].points[v][1][0]*scale,triangles[t].points[v][0][1]+triangles[t].points[v][1][1]*scale,triangles[t].points[v][0][2]+triangles[t].points[v][1][2]*scale);
                glEnd();
            }
        }
    }
}

-(void)renderVertices {
	//Get plain vanilla floats back out of dimensions array
    int x = (int)[[dimensions objectAtIndex:0] intValue];
    int y = (int)[[dimensions objectAtIndex:1] intValue];
    int z = (int)[[dimensions objectAtIndex:2] intValue];
    for (int i=0; i<x; i++) {
        for (int j=0; j<y; j++) {
            for (int k=0; k<z; k++) {
                float v = [[scalarData objectAtIndex:k + j*z + i*z*y] floatValue];
                float x_pos = ((GLfloat)i-((x-1)/2.0))/(x-1);
                float y_pos = ((GLfloat)j-((y-1)/2.0))/(y-1);
                float z_pos = ((GLfloat)k-((z-1)/2.0))/(z-1);
                if (v >= isovalue) {
                    GLfloat pos[3] = {x_pos, y_pos, z_pos};
                    drawCube(1, 0.01, pos);
                }
            }
        }
    }
}

-(void)renderIlluminationWithNormals:(BOOL)normals confined:(BOOL)confined {
    int arrayCount = [hits count];
    int x = (int)[[dimensions objectAtIndex:0] intValue];
    int y = (int)[[dimensions objectAtIndex:1] intValue];
    int z = (int)[[dimensions objectAtIndex:2] intValue];
    glColor3f(1.0, 1.0, 1.0);
    for (int i=0; i<arrayCount; i++) {
        Hit *hit = [hits objectAtIndex:i];
        if (([hit isovalue] > isovalue-maxValue*0.05 && [hit isovalue] < isovalue+maxValue*0.05 && confined == TRUE) || confined == FALSE) {
            float x_pos = ((GLfloat)[[hit location] x]-((x-1)/2.0))/(x-1);
            float y_pos = ((GLfloat)[[hit location] y]-((y-1)/2.0))/(y-1);
            float z_pos = ((GLfloat)[[hit location] z]-((z-1)/2.0))/(z-1);
            glBegin(GL_POINTS);
            glColor3f([[hit rgb] x], [[hit rgb] y], [[hit rgb] z]);
            glVertex3f(x_pos,y_pos,z_pos);
            glEnd();
            // Normals are rendered as lines that fade from white to blue
            if (normals == TRUE) {
                glBegin(GL_LINES);
                glColor3f(1.0f, 1.0f, 1.0f);
                glVertex3f(x_pos, y_pos, z_pos);
                glColor3f(0.0f, 0.0f, 1.0f);
                float scale = 0.1;
                glVertex3f(x_pos+[[hit normal] x]*scale,y_pos+[[hit normal] y]*scale,z_pos+[[hit normal] z]*scale);
                glEnd();
            }
        }
    }
}

// Dynamically resize array to accommodate new objects
-(int)addTriangle:(Triangle)item {

	if(num_elements == num_allocated) { // Are more refs required?
        
		if (num_allocated == 0)
			num_allocated = 10; // Start off with 10 refs
		else
			num_allocated *= 2; // Double the number of refs allocated
		
		// Make the reallocation transactional by using a temporary variable first
		void *_tmp = realloc([self triangles], (num_allocated * sizeof(Triangle)));
		
		// If the reallocation didn't go so well, inform the user and bail out
		if (!_tmp) { 
			fprintf(stderr, "ERROR: Couldn't realloc memory!\n");
			return(-1); 
		}
		[self setTriangles:(Triangle*)_tmp];	
	}
	
	triangles[num_elements] = item; 
	num_elements++;
	
	return num_elements;
}

- (float)trilinearInterpolationWithPosition:(Vec3 *)position inVoxel:(Vec3 *)voxel {
    
    int i = [voxel x];
    int j = [voxel y];
    int k = [voxel z];
    
    int y = (int)[[dimensions objectAtIndex:1] intValue];
    int z = (int)[[dimensions objectAtIndex:2] intValue];
    
    int is[8] = {
        // Bits are in reverse order
        k + j*z + i*z*y,                // 000  0
        k + j*z + (i+1)*z*y,            // 001  1
        k + (j+1)*z + i*z*y,            // 010  2
        k + (j+1)*z + (i+1)*z*y,        // 011  3
        (k+1) + j*z + i*z*y,            // 100  4
        (k+1) + j*z + (i+1)*z*y,        // 101  5
        (k+1) + (j+1)*z + i*z*y,        // 110  6
        (k+1) + (j+1)*z + (i+1)*z*y     // 111  7
    };
    
    float vs[8];
    for (int n=0; n<8; n++) {
        vs[n] = [[[self scalarData] objectAtIndex:is[n]] floatValue];
    }

    if (((vs[0] +vs[1] + vs[2] + vs[3] + vs[4] + vs[5] + vs[6] + vs[7]) / 8) == 0) {
        //NSLog(@"All Same!");
    }
    
    // calculate hit point
    float inx, iny, inz, outx, outy, outz,
    dx00, dx01, dx10, dx11, dxy0, dxy1, value;
    inx = [position x]-[voxel x];
    iny = [position y]-[voxel y];
    inz = [position z]-[voxel z];
    
    dx00 = LERP(inx, vs[0], vs[1]);
    dx01 = LERP(inx, vs[4], vs[5]);
    dx10 = LERP(inx, vs[2], vs[3]);
    dx11 = LERP(inx, vs[6], vs[7]);
    dxy0 = LERP(iny, dx00, dx10);
    dxy1 = LERP(iny, dx01, dx11);
    return LERP(inz, dxy0, dxy1);
}

- (Hit *)intersectRay:(Ray *)r withVoxel:(Vec3 *)voxel isovalue:(float)val tin:(Vec3 *)tin tout:(Vec3 *)tout {
    //NSLog(@"vox: %@ iso:%f tin:%@ tout:%@", voxel, val, tin, tout);
    // lookup voxel values
    // test if val within them
    int i = [voxel x];
    int j = [voxel y];
    int k = [voxel z];
    int y = (int)[[dimensions objectAtIndex:1] intValue];
    int z = (int)[[dimensions objectAtIndex:2] intValue];
    //NSLog(@"ijkyz: %d %d %d %d %d", i,j,k,y,z);
    int is[8] = {
        // Bits are in reverse order
        k + j*z + i*z*y,                // 000  0
        k + j*z + (i+1)*z*y,            // 001  1
        k + (j+1)*z + i*z*y,            // 010  2
        k + (j+1)*z + (i+1)*z*y,        // 011  3
        (k+1) + j*z + i*z*y,            // 100  4
        (k+1) + j*z + (i+1)*z*y,        // 101  5
        (k+1) + (j+1)*z + i*z*y,        // 110  6
        (k+1) + (j+1)*z + (i+1)*z*y     // 111  7
    };
    float vs[8];
    for (int n=0; n<8; n++) {
        vs[n] = [[[self scalarData] objectAtIndex:is[n]] floatValue];
        //NSLog(@"vs:%f", vs[n]);
    }
    // Figure out which ones are above the threshold
    int count = 0;
    for (int n=0; n<8; n++) {
        if (vs[n] >= val)
            count += 1;
    }
    //NSLog(@"count: %d", count);
    if (count != 0 && count != 8) {
        // return intersection with colour and hit point
        //NSLog(@"Intersect voxel: %@", voxel);

        // calculate hit point
        float pin, pout;
        pin = [self trilinearInterpolationWithPosition:tin inVoxel:voxel];
        pout = [self trilinearInterpolationWithPosition:tout inVoxel:voxel];
        
        //NSLog(@"pin:%f pout:%f", pin, pout);
        //NSLog(@"tin:%@ tout:%@", tin, tout);
        //NSLog(@"iso:%f", val);
        if (signof(pin-val) == signof(pout-val)) {
            //NSLog(@"NILL");
        } else {
            //NSLog(@"vox:%@ iso:%f tin:%@ tout:%@", voxel, val, tin, tout);
            // tin + ((tout - tin) * (val - pin) / (pout - pin))
            Vec3 *thit = [tin c_add:[[tout c_subtract:tin] c_product:((val - pin) / (pout - pin))]];
            Vec3 *norm_thit = [[thit c_divide:[[dimensions objectAtIndex:0] floatValue]] c_subtract:[Vec3 withX:0.5 Y:0.5 Z:0.5]];
            
            float u1 = ([thit x] - [voxel x]);  // voxels are 1 unit
            float v1 = ([thit y] - [voxel y]);  // rendering quotient
            float w1 = ([thit z] - [voxel z]);  // unnecessary
            
            float u[2] = {1 - u1, u1};
            float v[2] = {1 - v1, v1};
            float w[2] = {1 - w1, w1};
            
            int convert[2][2][2] = {
                { { 0, 4 }, { 2, 6 } },
                { { 1, 5 }, { 3, 7 } } };
            
            // normals
            double normal[3] = { 0, 0, 0 };
            for (int iv=0; iv<2; iv++) {
                for (int jv=0; jv<2; jv++) {
                    for (int kv=0; kv<2; kv++) {
                        normal[0] += (double)pow(-1, iv+1) * v[jv] * w[kv] * [[[self scalarData] objectAtIndex:is[convert[iv][jv][kv]]] doubleValue];
                        normal[1] += (double)pow(-1, jv+1) * u[iv] * w[kv] * [[[self scalarData] objectAtIndex:is[convert[iv][jv][kv]]] doubleValue];
                        normal[2] += (double)pow(-1, kv+1) * u[iv] * v[jv] * [[[self scalarData] objectAtIndex:is[convert[iv][jv][kv]]] doubleValue];
                    }
                }
            }
            Normalize(normal);
            Vec3 *vec_norm = [Vec3 withX:-normal[0] Y:-normal[1] Z:-normal[2]];
            
            Vec3 *light = [Vec3 withX:0.4 Y:1.2 Z:-0.7];
            Vec3 *to_light = [light c_subtract:norm_thit];
            [to_light normalize];
            
            float dot = [vec_norm dot:to_light];
            dot = (dot+fabs(dot))/2;  // cap at 0
            float ambient = 0.4;
            Vec3 *color = [Vec3 withX:dot+ambient Y:dot+ambient Z:dot+ambient];
            
            Hit *hit = [[Hit alloc] initWithLocation:thit rgb:color normal:vec_norm isovalue:val];
            
            return hit;
        }
    }
    return Nil;
}

- (Hit *)intersectRay:(Ray *)r withIsovalue:(float)val {
    //NSLog(@"ray:%@", r);
    // Set cur to nearest voxel (represented by integer)
    Vec3 *cur = [self voxelFromX:floor([[r origin] x])
                               Y:floor([[r origin] y])
                               Z:floor([[r origin] z])];
    
    // rel hold relative distance travelled (in unit voxels), initially zero
    Vec3 *rel = [[Vec3 alloc] initiWithX:0 Y:0 Z:0];
    
    // holds relative distance travelled in absolute units
    Vec3 *tRel = [[Vec3 alloc] initiWithX:0 Y:0 Z:0];
    
    float tParam = 0.0;
    float tParamNext = 0.0;
    
    Vec3 *sign = [[Vec3 alloc] initiWithX:1 Y:1 Z:1];
    if ([[r direction] x] < 0)
        [sign setX:-1];
    if ([[r direction] y] < 0)
        [sign setY:-1];
    if ([[r direction] z] < 0)
        [sign setZ:-1];
    
    // delta holds components for each dimension from ray direction
    // Useful to find next boundary of intersection
    Vec3 *delta = [[Vec3 alloc] initiWithX:0 Y:0 Z:0];
    if ([[r direction] x] != 0)
        [delta setX:1/[[r direction] x]];
    if ([[r direction] y] != 0)
        [delta setY:1/[[r direction] y]];
    if ([[r direction] z] != 0)
        [delta setZ:1/[[r direction] z]];
    //NSLog(@"delta: %@", delta);
    
    BOOL inside = TRUE;

    while (inside>0) {
        //NSLog(@"cur: %@", cur);
        
        // Get distances til next boundary
        float dx = fabs(([rel x] + [sign x]) * [delta x]);
        float dy = fabs(([rel y] + [sign y]) * [delta y]);
        float dz = fabs(([rel z] + [sign z]) * [delta z]);
        //NSLog(@"dx:%f dy:%f dz:%f", dx, dy, dz);

        // Find minimum distance that is not zero
        if (dx != 0 && (dx <= dy || dy == 0) && (dx <= dz || dz == 0)) {
            
            Vec3 *curNext = [[Vec3 alloc] initiWithX:floor([cur x] + [sign x]) Y:[cur y] Z:[cur z]];
            //NSLog(@"cur: %@ curNext: %@", cur, curNext);
            
            if ([cur x]     >= 0 &&
                [curNext x] >= 0 &&
                [cur x]     <= [[dimensions objectAtIndex:0] floatValue]-1 &&
                [curNext x] <= [[dimensions objectAtIndex:0] floatValue]-1) {
                
                //NSLog(@"YAY!");
                
                // Compute relative travel
                Vec3 *oldTRel = [[Vec3 alloc] initiWithX:[tRel x] Y:[tRel y] Z:[tRel z]];
                [rel setX:[rel x] + [sign x]];
                [tRel setX:[tRel x] + [[r direction] x]];
                [tRel setY:ceil([tRel y])];
                [tRel setZ:ceil([tRel z])];
                //NSLog(@"oldtRel: %@, tRel: %@", oldTRel, tRel);
                
                // Calculate t for current and next intersection
                tParam = sqrt(pow([oldTRel x],2) + pow([oldTRel y],2) + pow([oldTRel z],2));
                tParamNext = sqrt(pow([tRel x],2) + pow([tRel y],2) + pow([tRel z],2));
                //NSLog(@"tParam: %f, tParamNext: %f", tParam, tParamNext);
                
                Hit *test = nil;
                if ([sign x] < 0) {
                    test = [self intersectRay:r  withVoxel:curNext isovalue:val
                                          tin:[r pointAtParamater:tParam]
                                         tout:[r pointAtParamater:tParamNext]];
                } else {
                    test = [self intersectRay:r  withVoxel:cur isovalue:val
                                          tin:[r pointAtParamater:tParam]
                                         tout:[r pointAtParamater:tParamNext]];
                }
                
                // increment voxel
                cur = curNext;
                
                // return hit if found
                if (test) {
                    return test;
                }
                
            } else {
                inside = FALSE;
                //NSLog(@"NEIGH! cur: %@ curNext: %@", cur, curNext);
            }
        } else if (dy != 0 && (dy <= dx || dx == 0) && (dy <= dz || dx == 0)) {
            Vec3 *curNext = [[Vec3 alloc] initiWithX:[cur x] Y:floor([cur y] + [sign y]) Z:[cur z]];
            //NSLog(@"cur: %@ curNext: %@", cur, curNext);
            
            if ([cur y]     >= 0 &&
                [curNext y] >= 0 &&
                [cur y]     <= [[dimensions objectAtIndex:1] floatValue]-1 &&
                [curNext y] <= [[dimensions objectAtIndex:1] floatValue]-1) {
                
                //NSLog(@"YAY!");
                
                // Compute relative travel
                Vec3 *oldTRel = [[Vec3 alloc] initiWithX:[tRel x] Y:[tRel y] Z:[tRel z]];
                [rel setY:[rel y] + [sign y]];
                [tRel setX:ceil([tRel x])];
                [tRel setY:[tRel y] + [[r direction] y]];
                [tRel setZ:ceil([tRel z])];
                //NSLog(@"oldtRel: %@, tRel: %@", oldTRel, tRel);
                
                // Calculate t for current and next intersection
                tParam = sqrt(pow([oldTRel x],2) + pow([oldTRel y],2) + pow([oldTRel z],2));
                tParamNext = sqrt(pow([tRel x],2) + pow([tRel y],2) + pow([tRel z],2));
                //NSLog(@"tParam: %f, tParamNext: %f", tParam, tParamNext);
                
                Hit *test = nil;
                if ([sign y] < 0) {
                    test = [self intersectRay:r  withVoxel:curNext isovalue:val
                                          tin:[r pointAtParamater:tParam]
                                         tout:[r pointAtParamater:tParamNext]];
                } else {
                    test = [self intersectRay:r  withVoxel:cur isovalue:val
                                          tin:[r pointAtParamater:tParam]
                                         tout:[r pointAtParamater:tParamNext]];
                }
                
                // increment voxel
                cur = curNext;
                
                // return hit if found
                if (test) {
                    return test;
                }
                
            } else {
                inside = FALSE;
                //NSLog(@"NEIGH! cur: %@ curNext: %@", cur, curNext);
            }
        } else if (dz != 0 && (dz <= dx || dx == 0) && (dz <= dy || dx == 0)) {
            
            Vec3 *curNext = [[Vec3 alloc] initiWithX:[cur x] Y:[cur y] Z:floor([cur z] + [sign z])];
            //NSLog(@"cur: %@ curNext: %@", cur, curNext);
            
            if ([cur z]     >= 0 &&
                [curNext z] >= 0 &&
                [cur z]     <= [[dimensions objectAtIndex:2] floatValue]-1 &&
                [curNext z] <= [[dimensions objectAtIndex:2] floatValue]-1) {
                
                //NSLog(@"YAY!");
                
                // Compute relative travel
                Vec3 *oldTRel = [[Vec3 alloc] initiWithX:[tRel x] Y:[tRel y] Z:[tRel z]];
                [rel setZ:[rel z] + [sign z]];
                [tRel setX:ceil([tRel x])];
                [tRel setY:ceil([tRel y])];
                [tRel setZ:[tRel z] + [[r direction] z]];
                //NSLog(@"oldtRel: %@, tRel: %@", oldTRel, tRel);
                
                // Calculate t for current and next intersection
                tParam = sqrt(pow([oldTRel x],2) + pow([oldTRel y],2) + pow([oldTRel z],2));
                tParamNext = sqrt(pow([tRel x],2) + pow([tRel y],2) + pow([tRel z],2));
                //NSLog(@"tParam: %f, tParamNext: %f", tParam, tParamNext);
                
                Hit *test = nil;
                if ([sign z] < 0) {
                    test = [self intersectRay:r  withVoxel:curNext isovalue:val
                                          tin:[r pointAtParamater:tParam]
                                         tout:[r pointAtParamater:tParamNext]];
                } else {
                    test = [self intersectRay:r  withVoxel:cur isovalue:val
                                          tin:[r pointAtParamater:tParam]
                                         tout:[r pointAtParamater:tParamNext]];
                }
                
                // increment voxel
                cur = curNext;
                
                // return hit if found
                if (test) {
                    return test;
                }
                
            } else {
                inside = FALSE;
                //NSLog(@"NEIGH! cur: %@ curNext: %@", cur, curNext);
            }
            
        } else {
            NSLog(@"Error: d:%.1f %.1f %.1f cur:%@", dx, dy, dz, cur);
            inside = FALSE;
        }
    }
    return nil;
}

-(void)dealloc {
    [super dealloc];
    free(triangles);
}

@end
